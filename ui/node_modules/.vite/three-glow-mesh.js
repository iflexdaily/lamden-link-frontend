import {
  BackSide,
  Color,
  Face3,
  Mesh,
  ShaderMaterial
} from "./chunk-SQVQIKNX.js";

// node_modules/three-glow-mesh/dist/index.module.js
var t = { backside: true, coefficient: 0.5, color: "gold", size: 2, power: 1 };
function a(o, n, i) {
  return new ShaderMaterial({ depthWrite: false, fragmentShader: "\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity	= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}", transparent: true, uniforms: { coefficient: { value: o }, color: { value: new Color(n) }, power: { value: i } }, vertexShader: "\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal	= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n" });
}
function c(e, r) {
  var n = e.clone(), i = new Array(n.vertices.length);
  return n.faces.forEach(function(e2) {
    e2 instanceof Face3 ? (i[e2.a] = e2.vertexNormals[0], i[e2.b] = e2.vertexNormals[1], i[e2.c] = e2.vertexNormals[2]) : console.error("Face needs to be an instance of THREE.Face3.");
  }), n.vertices.forEach(function(e2, o) {
    var n2 = i[o], t2 = n2.y, a2 = n2.z;
    e2.x += n2.x * r, e2.y += t2 * r, e2.z += a2 * r;
  }), n;
}
function v(e, r) {
  r === void 0 && (r = t);
  var o = r.backside, v2 = r.coefficient, l = r.color, f = r.power, m = c(e, r.size), x = a(v2, l, f);
  return o && (x.side = BackSide), new Mesh(m, x);
}
export {
  c as createGlowGeometry,
  a as createGlowMaterial,
  v as createGlowMesh,
  t as defaultOptions
};
//# sourceMappingURL=three-glow-mesh.js.map
