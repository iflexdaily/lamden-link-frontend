{
  "version": 3,
  "sources": ["../three-glow-mesh/index.js"],
  "sourcesContent": ["import { BackSide, Color, Face3, Mesh, ShaderMaterial } from 'three';\n\nconst fragmentShader = `\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}`;\n\nconst vertexShader = `\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nexport const defaultOptions = {\n  backside: true,\n  coefficient: 0.5,\n  color: 'gold',\n  size: 2,\n  power: 1,\n};\n\n// Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\nexport function createGlowMaterial(coefficient, color, power) {\n  return new ShaderMaterial({\n    depthWrite: false,\n    fragmentShader,\n    transparent: true,\n    uniforms: {\n      coefficient: {\n        value: coefficient,\n      },\n      color: {\n        value: new Color(color),\n      },\n      power: {\n        value: power,\n      },\n    },\n    vertexShader,\n  });\n}\n\nexport function createGlowGeometry(geometry, size) {\n  // Gather vertexNormals from geometry.faces\n  const glowGeometry = geometry.clone();\n  const vertexNormals = new Array(glowGeometry.vertices.length);\n  glowGeometry.faces.forEach((face) => {\n    if (face instanceof Face3) {\n      vertexNormals[face.a] = face.vertexNormals[0];\n      vertexNormals[face.b] = face.vertexNormals[1];\n      vertexNormals[face.c] = face.vertexNormals[2];\n    } else {\n      console.error('Face needs to be an instance of THREE.Face3.');\n    }\n  });\n\n  // Modify the vertices according to vertexNormal\n  glowGeometry.vertices.forEach((vertex, i) => {\n    const { x, y, z } = vertexNormals[i];\n    vertex.x += x * size;\n    vertex.y += y * size;\n    vertex.z += z * size;\n  });\n\n  return glowGeometry;\n}\n\nexport function createGlowMesh(geometry, options = defaultOptions) {\n  const { backside, coefficient, color, size, power } = options;\n\n  const glowGeometry = createGlowGeometry(geometry, size);\n  const glowMaterial = createGlowMaterial(coefficient, color, power);\n\n  if (backside) {\n    glowMaterial.side = BackSide;\n  }\n\n  return new Mesh(glowGeometry, glowMaterial);\n}\n"],
  "mappings": ";;;;;;;;;AAEA,IA2Ba,IAAiB,EAC5B,UAAA,MACA,aAAa,KACb,OAAO,QACP,MAAM,GACN,OAAO;AAAA,WAI0B,GAAa,GAAO,GAAA;AACrD,SAAA,IAAW,eAAe,EACxB,YAAA,OACA,gBAAA,0fACA,aAAA,MACA,UAAU,EACR,aAAa,EACX,OAAO,KAET,OAAO,EACL,OAAO,IAAI,MAAM,MAEnB,OAAO,EACL,OAAO,OAGX,cAAA;;AAAA,WAI+B,GAAU,GAAA;AAE3C,MAAM,IAAe,EAAS,SACxB,IAAgB,IAAI,MAAM,EAAa,SAAS;AAmBtD,SAlBA,EAAa,MAAM,QAAQ,SAAC,IAAA;AACtB,kBAAgB,QAClB,GAAc,GAAK,KAAK,GAAK,cAAc,IAC3C,EAAc,GAAK,KAAK,GAAK,cAAc,IAC3C,EAAc,GAAK,KAAK,GAAK,cAAc,MAE3C,QAAQ,MAAM;MAKlB,EAAa,SAAS,QAAQ,SAAC,IAAQ,GAAA;AAAA,QAAA,KACjB,EAAc,IAAvB,KAAA,GAAA,GAAG,KAAA,GAAA;AACd,OAAO,KAAA,GADC,IACQ,GAChB,GAAO,KAAK,KAAI,GAChB,GAAO,KAAK,KAAI;MAGX;;AAAA,WAGsB,GAAU,GAAA;AAAA,EAAA,MAAA,UAAA,KAAU;AAAA,MACzC,IAA8C,EAA9C,UAAU,KAAoC,EAApC,aAAa,IAAuB,EAAvB,OAAa,IAAU,EAAV,OAEtC,IAAe,EAAmB,GAFc,EAAhB,OAGhC,IAAe,EAAmB,IAAa,GAAO;AAM5D,SAJI,KACF,GAAa,OAAO,WAAA,IAGX,KAAK,GAAc;;",
  "names": []
}
